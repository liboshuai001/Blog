---
title: 等待唤醒机制
date: 2020-10-20 15:50:25
tags:
	- Java
	- 线程
	- 基础知识
categories:
	- Java
cover:
	https://gitee.com/jasonM4A1/pictureHost/raw/master/20201020155113.jpg
---

# 等待唤醒机制

##  线程间通信

多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同，这个时候就需要线程通信了。

比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/20201020155431.jpg)

**为什么要处理线程间通信：**

多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。

**如何保证线程间通信有效利用资源：**

多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— **等待唤醒机制。**

## **什么是等待唤醒机制**

这是多个线程间的一种**协作**机制。谈到线程我们经常想到的是线程间的**竞争（race）**，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。

就是在一个线程进行了规定操作后，就进入等待状态（**wait()**）， 等待其他线程执行完他们的指定代码过后 再将其唤醒`notify()`。在有多个线程进行等待时， 如果需要，可以使用`notifyAll()`来唤醒所有的等待线程。

简单的来说：`wait/notify `就是线程间的一种协作机制。

## 等待和唤醒的方法

+ `wait()`

  线程不再活动，不再参与调度，进入` wait set `中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 `WAITING`。它还要等着别的线程执行一个**特别的动作**，也即是“**通知（notify）**”在这个对象上等待的线程从`wait set `中释放出来，重新进入到调度队列`(ready queue)`中。

+ `notify()`：选取所通知对象的`wait set`中的一个线程释放，一般是等待最久的那个线程。

+ `notify()`：释放所通知对象的` wait set `上的全部线程。

**需要注意的是：**

1. 即使你唤醒了一个线程，这个线程也不能立即恢复执行。因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用`wait `方法之后的地方恢复执行，即`Runnable`状态。如果争取锁失败了，就只能进入`Blocked`阻塞状态，等待下次争取到锁才能进入`Runnable`可运行状态。
2. `wait()`方法和`notify()`方法必须要由同一个锁对象调用。如果不是一个锁对象调用的，就起不到让线程等待和唤醒的作用了。
3. `wait()`方法和`notify()`是属于`Object`类的方法的，所以锁对象可以是任意对象。
4. `wait()`方法与`notify()`方法必须要在同步代码块或者是同步函数中使用，因为这两个方法是有锁对象调用的。

## 案例演示

等待唤醒机制其实就是经典的“生产者与消费者”的问题。

就拿生产包子、消费包子来说等待唤醒机制如何有效利用资源，下面为**案例思路**：

包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况（包子铺需要交替作两种陷的包子）。

**代码演示**

~~~java
//包子资源类
class BaoZi {
    //属性 皮和陷
    String pi;
    String xian;
    //包子资源状态
    boolean flag = false;
}

//吃货线程类
class ChiHuo extends Thread {
    //属性 包子类对象
    private BaoZi bz;

    //有参构造
    public ChiHuo(String name, BaoZi bz) {
        super(name);
        this.bz = bz;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (bz) {
                //如果没有包子，吃货就进入等待
                if (bz.flag == false) {
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //如果有包子，吃货就开始吃包子
                System.out.println("吃货正在吃：" + bz.pi + bz.xian + "的包子");
                //让线程睡眠1秒，充作吃包子的时间
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //吃货吃完包子，把包子状态改为false
                bz.flag = false;
                System.out.println("好了，吃货把包子吃完了，包子铺开始做包子吧~");
                System.out.println("-------------------------------------");
                //包子没了，唤醒包子铺线程开始做包子
                bz.notify();
            }
        }
    }
}

//包子铺线程类
class BaoZiPu extends Thread {
    //属性 包子类对象
    private BaoZi bz;

    //有参构造
    public BaoZiPu(String name, BaoZi bz) {
        super(name);
        this.bz = bz;
    }

    @Override
    public void run() {
        //包子馅计数器
        int count = 0;

        //做包子方法
        while (true) {
            synchronized (bz) {
                //如果有包子，包子铺线程就进去等待状态
                if (bz.flag == true) {
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //如果没有包子，则包子铺开始做包子
                System.out.println("包子铺开始做包子了");
                //让线程睡眠1秒，充作作包子的时间
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //两种陷的包子
                if (count % 2 == 0) {
                    bz.pi = "冰皮";
                    bz.xian = "五仁";
                } else {
                    bz.pi = "薄皮";
                    bz.xian = "牛肉大葱";
                }
                count++;
                //修改包子状态为true，表示包子做好了
                bz.flag = true;
                System.out.println("包子造好了：" + bz.pi + bz.xian + "， 吃货来吃吧");
                //唤醒等待吃货线程来吃包子
                bz.notify();
            }
        }
    }
}

//测试类
public class Test {
    public static void main(String[] args) {
        //创建包子类对象
        BaoZi bz = new BaoZi();
        //创建吃货线程,并启动线程
        new ChiHuo("吃货",bz).start();
        //创建包子铺线程,并启动线程
        new BaoZiPu("包子铺",bz).start();
    }
}
~~~

**执行结果**

~~~java
包子铺开始做包子了
包子造好了：冰皮五仁， 吃货来吃吧
吃货正在吃：冰皮五仁的包子
好了，吃货把包子吃完了，包子铺开始做包子吧~
-------------------------------------
包子铺开始做包子了
包子造好了：薄皮牛肉大葱， 吃货来吃吧
吃货正在吃：薄皮牛肉大葱的包子
好了，吃货把包子吃完了，包子铺开始做包子吧~
-------------------------------------
包子铺开始做包子了
包子造好了：冰皮五仁， 吃货来吃吧
吃货正在吃：冰皮五仁的包子
好了，吃货把包子吃完了，包子铺开始做包子吧~
-------------------------------------
包子铺开始做包子了
包子造好了：薄皮牛肉大葱， 吃货来吃吧
吃货正在吃：薄皮牛肉大葱的包子
好了，吃货把包子吃完了，包子铺开始做包子吧~
-------------------------------------
    ......
    ......
~~~

