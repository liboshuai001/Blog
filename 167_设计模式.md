# 1，设计模式概述

## 1.1 软件设计模式的产生背景

"设计模式"最初并不是出现在软件设计中，而是被用于建筑领域的设计中。

1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任`克里斯托夫·亚历山大（Christopher Alexander）`在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。

1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  

## 1.2 软件设计模式的概念

软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。

## 1.3 学习设计模式的必要性

设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。

正确使用设计模式具有以下优点。

- 可以提高程序员的思维能力、编程能力和设计能力。
- 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
- 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。

## 1.4 设计模式分类

* **创建型模式**

  用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
  
* **结构型模式**

  用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。

* **行为型模式**

  用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

# 2, UML图

统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。

UML 从目标系统的不同角度出发，定义了用例图、**类图**、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。

## 2.1 类图概述

类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。

## 2.2 类图的作用

* 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；
* 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。

## 2.3 类图表示法

### 2.3.1 类的表示方式 

在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/Employee.jpg)

属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：

* +：表示public
* -：表示private
* #：表示protected

属性的完整表示方式是： **可见性  名称 ：类型 [ = 缺省值]**  

方法的完整表示方式是： **可见性  名称(参数列表) [ ： 返回类型]**

> 注意：
>
> 1，中括号中的内容表示是可选的
>
> 2，也有将类型放在变量名前面，返回值类型放在方法名前面

**举个栗子：**

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/demo.png)

上图Demo类定义了三个方法：

* method()方法：修饰符为public，没有参数，没有返回值。
* method1()方法：修饰符为private，没有参数，返回值类型为String。
* method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。

### 2.3.2 类与类之间关系的表示方式

#### 2.3.2.1 关联关系

关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。

关联又可以分为单向关联，双向关联，自关联。

**1，单向关联**

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/customer_address.png)

在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。

**2，双向关联**

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/customer_product.png)

从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。

在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。

**3，自关联**

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/node.png)

自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。

#### 2.3.2.2 聚合关系

聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。

聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。

在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/image-20191229173422328.png)

#### 2.3.2.3 组合关系

组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。

在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。

在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/image-20191229173455149.png)

#### 2.3.2.4 依赖关系

依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。

在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/image-20191229173518926.png)

#### 2.3.2.6 实现关系

实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。

在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/image-20191229173554296.png)

# 3，软件设计原则

在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。

## 3.1 开闭原则

**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。

想要达到这样的效果，我们需要使用接口和抽象类。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

下面以 `搜狗输入法` 的皮肤为例介绍开闭原则的应用。

【例】`搜狗输入法` 的皮肤设计。

分析：`搜狗输入法` 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/open-close.png)

**案例演示**

>  此案例是建立在上文`搜狗输入法皮肤`分析的基础上进行代码工程实现的,工程思路详细细节回看上文.

1. 新建普通Jave maven工程,最终项目目录结构如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210907143359.png)

2. 新建抽象皮肤类`AbstractSkin`, 此类只提供一个展示皮肤的抽象方法,供其实现类实现

   ```java
   package xyz.rtx3090.designPattern.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AbstractSkin
    * @createTime 2021年09月07日 12:04:00
    * @Description 抽象皮肤类
    */
   public abstract class AbstractSkin {
       /**
        * @title 显示皮肤的方法
        * @description 
        * @author BernardoLi
        * @updateTime 2021/9/7 12:05 
        * @throws 
        */
       public abstract void display();
   }
   ```

3. 新建默认皮肤子类`DefaultSkin`,实现了自己的展示皮肤方法

   ```java
   package xyz.rtx3090.designPattern.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName DefaultSkin
    * @createTime 2021年09月07日 12:06:00
    * @Description 默认皮肤子类 继承了父类 皮肤抽象类
    */
   public class DefaultSkin extends AbstractSkin{
       @Override
       public void display() {
           System.out.println("默认皮肤");
       }
   }
   ```

4. 新建Rtx3090皮肤子类`rtx3090Skin`,也实现了自己的展示皮肤方法

   ```java
   package xyz.rtx3090.designPattern.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Rtx3090Skin
    * @createTime 2021年09月07日 12:07:00
    * @Description rtx3090皮肤子类 继承了父类 皮肤抽象类
    */
   public class Rtx3090Skin extends AbstractSkin{
       @Override
       public void display() {
           System.out.println("rtx3090皮肤");
       }
   }
   ```

5. 新建搜狗输入法类`SougouInput`,可以安装需要各种皮肤,私有属性为抽象类`skin`

   ```java
   package xyz.rtx3090.designPattern.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName SougouInput
    * @createTime 2021年09月07日 12:07:00
    * @Description 搜狗输入法 可以安装各种皮肤
    */
   public class SougouInput {
       private AbstractSkin skin;
   
       /**
        * @title 设置皮肤
        * @description 导入设置不同种类的皮肤；同一个抽象类可以被多个不同的子类实现
        * @author BernardoLi
        * @updateTime 2021/9/7 13:20
        * @throws
        */
       public void setSkin(AbstractSkin skin) {
           this.skin = skin;
       }
   
       /**
        * @title 展示皮肤
        * @description 应用不同种类的皮肤，展示的效果自然不同；不同抽象类子类其实现的方法自然也各不相同！
        * @author BernardoLi
        * @updateTime 2021/9/7 13:21
        * @throws
        */
       public void display() {
           skin.display();
       }
   }
   ```

6. 新建测试类`SougouInputTest`, 用来测试搜狗输入法展示其更换皮肤的能力

   ```java
   package xyz.rtx3090.designPattern.demo01;
   
   import org.junit.jupiter.api.Test;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName SougouInputTest
    * @createTime 2021年09月07日 13:27:00
    * @Description 搜狗输入法展示其更换皮肤的能力
    */
   class SougouInputTest {
       /**
        * @title 应用默认皮肤
        * @author BernardoLi
        * @updateTime 2021/9/7 13:29
        * @throws
        * @description 搜狗输入法应用安装默认皮肤；
        * 给SougouInput类私有属性AbstractSkin抽象类赋值，默认皮肤DefaultSkin子类。
        * 此时SougouInput类display方法就调用了默认皮肤DefaultSkin子类的display方法
        */
       @Test
       public void DefaultSkinTest() {
           //1.创建搜狗输入法对象
           SougouInput sougouInput = new SougouInput();
           //2.创建默认皮肤对象
           DefaultSkin defaultSkin = new DefaultSkin();
           //3.将默认皮肤应用到搜狗输入法中
           sougouInput.setSkin(defaultSkin);
           //4.搜狗输入法显示皮肤
           sougouInput.display();//执行结果：默认皮肤
       }
   
       /**
        * @title 应用Rtx3090皮肤
        * @author BernardoLi
        * @updateTime 2021/9/7 13:36
        * @throws
        * @description 搜狗输入法应用安装Rtx3090皮肤；
        * 给SougouInput类私有属性AbstractSkin抽象类赋值——Rtx3090皮肤Rtx3090Skin子类。
        * 此时SougouInput类display方法就调用了Rtx3090皮肤Rtx3090Skin子类的display方法
        */
       @Test
       public void Rtx3090SkinTest() {
           //1.创建搜狗输入法对象
           SougouInput sougouInput = new SougouInput();
           //2.创建Rtx3090皮肤对象
           Rtx3090Skin rtx3090Skin = new Rtx3090Skin();
           //3.将Rtx3090皮肤应用到搜狗输入法中
           sougouInput.setSkin(rtx3090Skin);
           //4.搜狗输入法显示皮肤
           sougouInput.display();//执行结果：rtx3090皮肤
       }
   
   }
   ```

搜狗输入法更换皮肤,不需要对其他代码进行任何修改,只需要在赋值私有属性时更换一下抽象类的实现子类.

以后想进行皮肤种类的扩展,只需要新建皮肤抽象类的实现子类即可.契合`开闭原则`,对扩展开发,对修改关闭!

## 3.2 里氏代换原则

里氏代换原则是面向对象设计的基本原则之一。

**里氏代换原则：任何基类可以出现的地方，子类一定可以出现。**通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

下面看一个里氏替换原则中经典的一个例子

【例】正方形不是长方形。

在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/正方形不是长方形.png)

**案例演示**

>  此案例是建立在上文`正方形不是长方形`分析的基础上进行代码工程实现的,工程思路详细细节回看上文.

1. 新建普通Jave maven工程,最终项目目录结构如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210907143436.png)

2. 新建长方形类`Rectangle`,有两个私有属性——长`length`和宽`width`

   ```java
   package xyz.rtx3090.designPattern.demo02.before;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Rectangle
    * @createTime 2021年09月07日 13:58:00
    * @Description 长方形类
    */
   public class Rectangle {
       private double length;
       private double width;
   
       //setter and getter
   
       public double getLength() {
           return length;
       }
   
       public void setLength(double length) {
           this.length = length;
       }
   
       public double getWidth() {
           return width;
       }
   
       public void setWidth(double width) {
           this.width = width;
       }
   }
   ```

3. 新建正方形类,继承父类长方形类`Rectangle`,它设置长度和设置宽度的方法都是同时设置长宽使其相同

   ```java
   package xyz.rtx3090.designPattern.demo02.before;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Square
    * @createTime 2021年09月07日 14:00:00
    * @Description 正方形类
    */
   public class Square extends Rectangle{
       /**
        * @title 设置正方形的长
        * @author BernardoLi
        * @updateTime 2021/9/7 14:03
        * @throws
        * @description 设置正方形的长和宽一样
        */
       @Override
       public void setLength(double length) {
           super.setLength(length);
           super.setWidth(length);
       }
   
       /**
        * @title 设置正方形的宽
        * @author BernardoLi
        * @updateTime 2021/9/7 14:03
        * @throws
        * @description 设置正方形的宽和长一样
        */
       @Override
       public void setWidth(double width) {
           super.setWidth(width);
           super.setLength(width);
       }
   }
   ```

4. 新建测试类`RectangleTest`,测试父类`Rectangle`与子类`Square`是否符合`里氏代换原则`

   ```java
   package xyz.rtx3090.designPattern.demo02.before;
   
   import org.junit.jupiter.api.Test;
   
   class RectangleTest {
   
       /**
        * @title 测试长方形扩宽
        * @author BernardoLi
        * @updateTime 2021/9/7 14:23
        * @throws
        * @description 对长方形进行扩宽操作，然后打印其长宽度
        */
       @Test
       public void RectangleTest() {
           //创建长方形对象
           Rectangle rectangle = new Rectangle();
           //设置长和宽
           rectangle.setLength(20);
           rectangle.setWidth(10);
           //对长方形进行扩宽
           resize(rectangle);
           //打印长方形的长宽度
           printLengthAndWidth(rectangle);
       }
   
       /**
        * @title 测试正方形扩宽
        * @author BernardoLi
        * @updateTime 2021/9/7 14:30
        * @throws
        * @description 对正方形进行扩宽操作，然后打印其长宽度（运行失败）
        */
       @Test
       public void SquareTest() {
           //创建正方形对象
           Square square = new Square();
           //设置长宽
           square.setLength(10);
           //对正方形扩宽操作
           resize(square);
           //打印正方形长宽
           printLengthAndWidth(square);
       }
   
       /**
        * @throws
        * @title 扩宽方法
        * @author BernardoLi
        * @updateTime 2021/9/7 14:15
        * @description 将宽扩展到比长还要长为止
        */
       public static void resize(Rectangle rectangle) {
           //判断宽是否小于长
           while (rectangle.getWidth() <= rectangle.getLength()) {
               //如果宽小于长，则让宽+1
               rectangle.setWidth(rectangle.getWidth() + 1);
           }
       }
   
       /**
        * @throws
        * @title 打印长宽
        * @author BernardoLi
        * @updateTime 2021/9/7 14:17
        * @description 打印出长方形的长度和宽度的数值
        */
       public static void printLengthAndWidth(Rectangle rectangle) {
           System.out.println("Length = " + rectangle.getLength());
           System.out.println("Width = " + rectangle.getWidth());
       }
   }
   ```

我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形则不适合。
我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。

如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/正方形不是长方形改进.png)

**改进案例演示**

> 此案例是对上一个`案例演示`的改进, 改进原则和思路,在上次项目结尾已有说明

1. 新建普通Jave maven工程,最终项目目录结构如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210907151045.png)

2. 新建`Quadrilateral`四边形接口,有两个方法——分别是获取长度的和获取宽度的

   ```java
   package xyz.rtx3090.designPattern.demo02.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Quadrilateral
    * @createTime 2021年09月07日 14:44:00
    * @Description 四边形接口
    */
   public interface Quadrilateral {
       //获取长度
       double getLength();
   
       //获取宽度
       double getWidth();
   }
   ```

3. 新建`Rectangle`长方形类,有两个私有属性——长度和宽度,重写`Quadrilateral`四边形接口的方法,并定义出setter and getter方法

   ```java
   package xyz.rtx3090.designPattern.demo02.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Rectangle
    * @createTime 2021年09月07日 14:48:00
    * @Description 长方形类
    */
   public class Rectangle implements Quadrilateral{
   
       private double length;
       private double width;
   
       //setter
   
       public void setLength(double length) {
           this.length = length;
       }
   
       public void setWidth(double width) {
           this.width = width;
       }
   
       @Override
       public double getLength() {
           return length;
       }
   
       @Override
       public double getWidth() {
           return width;
       }
   }
   ```

4. 新建`Square`正方形类,有一个私有属性`side`边,重写`Quadrilateral`四边形接口的方法,并定义出setter and getter方法

   ```java
   package xyz.rtx3090.designPattern.demo02.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Square
    * @createTime 2021年09月07日 14:45:00
    * @Description 正方形类
    */
   public class Square implements Quadrilateral{
       private double side;
   
       //setter and getter
   
       public double getSide() {
           return side;
       }
   
       public void setSide(double side) {
           this.side = side;
       }
   
       @Override
       public double getLength() {
           return side;
       }
   
       @Override
       public double getWidth() {
           return side;
       }
   }
   ```

5. 新建`QuadrilateralTest`测试类, 测试`Rectangle`长方形类与`Square`正方形类是否还会出现上个案例出现的问题

   ```java
   package xyz.rtx3090.designPattern.demo02.after;
   
   import org.junit.jupiter.api.Test;
   
   class QuadrilateralTest {
       /**
        * @title 测试长方形扩宽
        * @author BernardoLi
        * @updateTime 2021/9/7 14:58
        * @throws
        * @description 对长方形进行扩宽操作，然后打印其长宽度
        */
       @Test
       public void RectangleTest() {
           //创建长方形对象
           Rectangle rectangle = new Rectangle();
           //设置长和宽
           rectangle.setLength(20);
           rectangle.setWidth(10);
           //对长方形进行扩宽
           resize(rectangle);
           //打印长方形的长宽
           printLengthAndWidth(rectangle);
       }
   
       /**
        * @title 测试正方形扩宽
        * @author BernardoLi
        * @updateTime 2021/9/7 15:03
        * @throws
        * @description 对正方形进行扩宽操作，然后打印其长宽度（方法设置使其无法扩宽）
        */
       @Test
       public void SquareTest() {
           //创建正方形对象
           Square square = new Square();
           //设置长宽
           square.setSide(10);
           /*
               想将正方形对象传入resize方法进行扩宽
               发现Square正方形类不是Rectangle长方形类的子类
               所以正方形对象无法被传入resize方法中进行扩宽
               这样Square类与Quadrilateral接口之间
               和Rectangle类与Quadrilateral接口之间
               就都符合了"里氏代换原则"了
            */
       }
   
       /**
        * @throws
        * @title 扩宽方法
        * @author BernardoLi
        * @updateTime 2021/9/7 14:54
        * @description 将宽扩展到比长还要长为止
        */
       public static void resize(Rectangle rectangle) {
           //判断宽是否小于长
           while (rectangle.getWidth() <= rectangle.getLength()) {
               //如果宽小于长，则让宽+1
               rectangle.setWidth(rectangle.getWidth() + 1);
           }
       }
   
       /**
        * @throws
        * @title 打印长宽
        * @author BernardoLi
        * @updateTime 2021/9/7 14:55
        * @description 打印出长方形的长度和宽度的数值
        */
       public static void printLengthAndWidth(Quadrilateral quadrilateral) {
           System.out.println("Length = " + quadrilateral.getLength());
           System.out.println("width = " + quadrilateral.getWidth());
       }
   }
   ```

       想将正方形对象传入resize方法进行扩宽
       发现Square正方形类不是Rectangle长方形类的子类
       所以正方形对象无法被传入resize方法中进行扩宽
       这样Square类与Quadrilateral接口之间
       Rectangle类与Quadrilateral接口之间
       就都符合了"里氏代换原则"了

想将正方形对象传入resize方法进行扩宽

发现Square正方形类不是Rectangle长方形类的子类, 所以正方形对象无法被传入resize方法中进行扩宽

这样Square类与Quadrilateral接口之间、Rectangle类与Quadrilateral接口之间, 就都符合了"里氏代换原则"了

## 3.3 依赖倒转原则

**高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。**简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

下面看一个例子来理解依赖倒转原则

【例】组装电脑

现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。

**案例演示**

> 此案例是建立在上文`组装电脑`分析的基础上进行代码工程实现的,工程思路详细细节回看上文.

1. 新建普通Java maven项目, 最终工程目录结构如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908071405.png)

2. 新建希捷硬盘类, 提供存储数据和获取数据的方法

   ```java
   package xyz.rtx3090.designPattern.demo03.before;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName XiJieHardDisk
    * @createTime 2021年09月07日 20:01:00
    * @Description 希捷硬盘类
    */
   public class XiJieHardDisk {
   
       /**
        * @title 存储数据的方法
        * @author BernardoLi 
        * @updateTime 2021/9/7 20:03 
        * @throws 
        * @description 
        */
       public void save(String data) {
           System.out.println("使用希捷硬盘存储的数据为：" + data);
       }
   
       /**
        * @title 获取数据的方法
        * @author BernardoLi
        * @updateTime 2021/9/7 20:05
        * @throws
        * @description
        */
       public String get() {
           System.out.println("使用希捷硬盘取出数据");
           return "数据";
       }
   }
   ```

3. 新建IntelCpu类, 提供运行IntelCpu的方法

   ```java
   package xyz.rtx3090.designPattern.demo03.before;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName IntelCpu
    * @createTime 2021年09月07日 20:05:00
    * @Description 英特尔处理器类
    */
   public class IntelCpu {
   
       /**
        * @title 运行IntelCpu
        * @author BernardoLi 
        * @updateTime 2021/9/7 20:06 
        * @throws 
        * @description 
        */
       public void run() {
           System.out.println("使用IntelCpu");
       }
   }
   ```

4. 新建金士顿内存条类, 提供使用内存条保存数据的方法

   ```java
   package xyz.rtx3090.designPattern.demo03.before;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName KingstonMemory
    * @createTime 2021年09月07日 20:07:00
    * @Description 金士顿内存条类
    */
   public class KingstonMemory {
   
       /**
        * @title 使用内存条保存数据
        * @author BernardoLi 
        * @updateTime 2021/9/8 07:09 
        * @throws 
        * @description 
        */
       public void save() {
           System.out.println("使用金士顿内存条");
       }
   }
   ```

5. 新建计算机类, 三个私有属性——希捷硬盘类,IntelCpu类和金士顿内存条类, 以及自身的setter、getter方法,和最后的运行计算机的方法

   ```java
   package xyz.rtx3090.designPattern.demo03.before;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Computer
    * @createTime 2021年09月07日 20:08:00
    * @Description TODO
    */
   public class Computer {
   
       private XiJieHardDisk xiJieHardDisk;
       private IntelCpu intelCpu;
       private KingstonMemory kingstonMemory;
   
       //setter and getter
   
       public XiJieHardDisk getXiJieHardDisk() {
           return xiJieHardDisk;
       }
   
       public void setXiJieHardDisk(XiJieHardDisk xiJieHardDisk) {
           this.xiJieHardDisk = xiJieHardDisk;
       }
   
       public IntelCpu getIntelCpu() {
           return intelCpu;
       }
   
       public void setIntelCpu(IntelCpu intelCpu) {
           this.intelCpu = intelCpu;
       }
   
       public KingstonMemory getKingstonMemory() {
           return kingstonMemory;
       }
   
       public void setKingstonMemory(KingstonMemory kingstonMemory) {
           this.kingstonMemory = kingstonMemory;
       }
   
       /**
        * @title 运行计算机
        * @author BernardoLi
        * @updateTime 2021/9/8 00:30
        * @throws
        * @description 运行计算机，依次从硬盘获取数据，运行cpu，内存进行保存操作
        */
       public void run() {
           System.out.println("运行计算机");
           System.out.println("从硬盘上获取数据：" + xiJieHardDisk.get());
           intelCpu.run();
           kingstonMemory.save();
       }
   }
   ```

6. 新建计算机测试类, 用于组装电脑,测试计算机运行情况

   ```java
   package xyz.rtx3090.designPattern.demo03.before;
   
   import org.junit.jupiter.api.Test;
   
   class ComputerTest {
   
       @Test
       public void testComputer() {
           //创建组件对象
           XiJieHardDisk xiJieHardDisk = new XiJieHardDisk();
           IntelCpu intelCpu = new IntelCpu();
           KingstonMemory kingstonMemory = new KingstonMemory();
   
           //创建计算机对象
           Computer computer = new Computer();
   
           //组装计算机
           computer.setXiJieHardDisk(xiJieHardDisk);
           computer.setIntelCpu(intelCpu);
           computer.setKingstonMemory(kingstonMemory);
   
           //运行计算机
           computer.run();
       }
   }
   ```

上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。

根据依赖倒转原则进行改进：

代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。

**类图如下**

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/依赖倒转原则改进.png)

**改进案例演示**

> 此案例是对上一个`案例演示`的改进, 改进原则和思路,在上次项目结尾已有说明

1. 工程目录结构如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908075847.png)

2. 新建硬盘接口

   ```java
   package xyz.rtx3090.designPattern.demo03.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName HardDisk
    * @createTime 2021年09月08日 07:18:00
    * @Description 硬盘接口
    */
   public interface HardDisk {
   
       /**
        * @title 存储数据
        * @author BernardoLi 
        * @updateTime 2021/9/8 07:21 
        * @throws 
        * @description 
        */
       void save(String data);
   
       /**
        * @title 获取数据
        * @author BernardoLi 
        * @updateTime 2021/9/8 07:22
        * @throws 
        * @description 
        */
       public String get();
   }
   ```

3. 新建Cpu接口

   ```java
   package xyz.rtx3090.designPattern.demo03.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Cpu
    * @createTime 2021年09月08日 07:22:00
    * @Description Cpu接口
    */
   public interface Cpu {
       
       /**
        * @title 运行Cpu
        * @author BernardoLi 
        * @updateTime 2021/9/8 07:23
        * @throws 
        * @description 
        */
       void run();
   }
   ```

4. 新建内存条接口

   ```java
   package xyz.rtx3090.designPattern.demo03.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Memory
    * @createTime 2021年09月08日 07:23:00
    * @Description 内存条接口
    */
   public interface Memory {
   
       /**
        * @title 保存数据
        * @author BernardoLi
        * @updateTime 2021/9/8 07:24
        * @throws
        * @description
        */
       void save();
   }
   ```

5. 新建希捷硬盘类

   ```java
   package xyz.rtx3090.designPattern.demo03.after.impl;
   
   import xyz.rtx3090.designPattern.demo03.after.HardDisk;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName XiJieHardDisk
    * @createTime 2021年09月07日 20:01:00
    * @Description 希捷硬盘类
    */
   public class XiJieHardDisk implements HardDisk {
   
       /**
        * @title 存储数据的方法
        * @author BernardoLi 
        * @updateTime 2021/9/7 20:03 
        * @throws 
        * @description 
        */
       public void save(String data) {
           System.out.println("使用希捷硬盘存储的数据为：" + data);
       }
   
       /**
        * @title 获取数据的方法
        * @author BernardoLi
        * @updateTime 2021/9/7 20:05
        * @throws
        * @description
        */
       public String get() {
           System.out.println("从希捷硬盘取出数据");
           return "数据";
       }
   }
   ```

6. 新建英特尔处理器类

   ```java
   package xyz.rtx3090.designPattern.demo03.after.impl;
   
   import xyz.rtx3090.designPattern.demo03.after.Cpu;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName IntelCpu
    * @createTime 2021年09月07日 20:05:00
    * @Description 英特尔处理器类
    */
   public class IntelCpu implements Cpu {
   
       /**
        * @title 运行IntelCpu
        * @author BernardoLi 
        * @updateTime 2021/9/7 20:06 
        * @throws 
        * @description 
        */
       public void run() {
           System.out.println("运行IntelCpu");
       }
   }
   ```

7. 金士顿内存条类

   ```java
   package xyz.rtx3090.designPattern.demo03.after.impl;
   
   import xyz.rtx3090.designPattern.demo03.after.Memory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName KingstonMemory
    * @createTime 2021年09月07日 20:07:00
    * @Description 金士顿内存条类
    */
   public class KingstonMemory implements Memory {
   
       /**
        * @title 使用内存条保存数据
        * @author BernardoLi 
        * @updateTime 2021/9/8 07:16
        * @throws 
        * @description 
        */
       public void save() {
           System.out.println("金士顿内存条保存数据");
       }
   }
   ```

8. 西部数据硬盘

   ```java
   package xyz.rtx3090.designPattern.demo03.after.impl;
   
   import xyz.rtx3090.designPattern.demo03.after.HardDisk;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName WdHardDisk
    * @createTime 2021年09月08日 07:43:00
    * @Description 西部数据硬盘
    */
   public class WdHardDisk implements HardDisk {
       /**
        * @title 存储数据
        * @author BernardoLi 
        * @updateTime 2021/9/8 07:44 
        * @throws 
        * @description 
        */
       @Override
       public void save(String data) {
           System.out.println("使用西部数据硬盘存储的数据为：" + data);
       }
   
       /**
        * @title 获取数据
        * @author BernardoLi 
        * @updateTime 2021/9/8 07:44 
        * @throws 
        * @description 
        */
       @Override
       public String get() {
           System.out.println("从西部数据硬盘取出数据");
           return "数据";
       }
   }
   ```

9. AMDCpu

   ```java
   package xyz.rtx3090.designPattern.demo03.after.impl;
   
   import xyz.rtx3090.designPattern.demo03.after.Cpu;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AmdCpu
    * @createTime 2021年09月08日 07:40:00
    * @Description AMDCpu
    */
   public class AmdCpu implements Cpu {
       
       /**
        * @title 运行AmdCpu
        * @author BernardoLi
        * @updateTime 2021/9/8 07:41 
        * @throws 
        * @description 
        */
       @Override
       public void run() {
           System.out.println("运行AmdCpu");
       }
   }
   ```

10. 海盗船内存条

    ```java
    package xyz.rtx3090.designPattern.demo03.after.impl;
    
    import xyz.rtx3090.designPattern.demo03.after.Memory;
    
    /**
     * @author BernardoLi
     * @version 1.0.0
     * @ClassName CorsairMemory
     * @createTime 2021年09月08日 07:46:00
     * @Description 海盗船内存条
     */
    public class CorsairMemory implements Memory {
        /**
         * @title 保存数据
         * @author BernardoLi
         * @updateTime 2021/9/8 07:46
         * @throws
         * @description
         */
        @Override
        public void save() {
            System.out.println("海盗船内存条保存数据");
        }
    }
    ```

11. 计算机类

    ```java
    package xyz.rtx3090.designPattern.demo03.after;
    
    /**
     * @author BernardoLi
     * @version 1.0.0
     * @ClassName Computer
     * @createTime 2021年09月08日 07:25:00
     * @Description 计算机类
     */
    public class Computer {
    
        private HardDisk hardDisk;
        private Cpu cpu;
        private Memory memory;
    
        //setter and getter
    
        public HardDisk getHardDisk() {
            return hardDisk;
        }
    
        public void setHardDisk(HardDisk hardDisk) {
            this.hardDisk = hardDisk;
        }
    
        public Cpu getCpu() {
            return cpu;
        }
    
        public void setCpu(Cpu cpu) {
            this.cpu = cpu;
        }
    
        public Memory getMemory() {
            return memory;
        }
    
        public void setMemory(Memory memory) {
            this.memory = memory;
        }
    
        /**
         * @title 运行计算机
         * @author BernardoLi 
         * @updateTime 2021/9/8 07:27 
         * @throws 
         * @description 
         */
        public void run() {
            System.out.println("运行计算机");
            //从硬盘获取数据
            hardDisk.get();
            //运行cpu
            cpu.run();
            //内存条进行数据保存
            memory.save();
        }
    }
    ```

12. 计算机测试类

    ```java
    package xyz.rtx3090.designPattern.demo03.after;
    
    import org.junit.jupiter.api.Test;
    import xyz.rtx3090.designPattern.demo03.after.impl.*;
    
    class ComputerTest {
        /**
         * @throws
         * @title 测试计算机套件一
         * @author BernardoLi
         * @updateTime 2021/9/8 07:33
         * @description 使用希捷硬盘、英特尔处理器、金士顿内存条组装计算机，并运行测试
         */
        @Test
        public void testComputer01() {
            //创建组装对象
            HardDisk xiJieHardDisk = new XiJieHardDisk();
            Cpu intelCpu = new IntelCpu();
            Memory kingstonMemory = new KingstonMemory();
    
            //创建计算机对象
            Computer computer = new Computer();
    
            //组装计算机
            computer.setHardDisk(xiJieHardDisk);
            computer.setCpu(intelCpu);
            computer.setMemory(kingstonMemory);
    
            //运行计算机
            computer.run();
        }
    
        /**
         * @title 测试计算机套件二
         * @author BernardoLi
         * @updateTime 2021/9/8 07:49
         * @throws
         * @description 使用西部数据硬盘、AMD处理器、海盗船内存条组装计算机，并运行测试
         */
        @Test
        public void testComputer02() {
            //创建组件对象
            HardDisk wdHardDisk = new WdHardDisk();
            Cpu amdCpu = new AmdCpu();
            Memory corsairMemory = new CorsairMemory();
    
            //创建计算机对象
            Computer computer = new Computer();
    
            //组装计算机
            computer.setHardDisk(wdHardDisk);
            computer.setCpu(amdCpu);
            computer.setMemory(corsairMemory);
    
            //运行计算机
            computer.run();
        }
    }
    ```

面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。

## 3.4 接口隔离原则

**客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。**

下面看一个例子来理解接口隔离原则

【例】安全门案例

我们需要创建一个`rtx3090`品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/接口隔离原则.png)

**案例演示**

> 此案例是建立在上文`安全门`分析的基础上进行代码工程实现的,工程思路详细细节回看上文.

1. 最终项目目录结构如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908094255.png)

2. 安全门接口

   ```java
   package xyz.rtx3090.designPattern.demo04.before;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName SafetyDoor
    * @createTime 2021年09月08日 09:34:00
    * @Description 安全门接口
    */
   public interface SafetyDoor {
   
       //防盗
       void antiTheft();
   
       //防火
       void fireProof();
   
       //防水
       void waterProof();
   }
   ```

3. Rtx3090品牌安全门类

   ```java
   package xyz.rtx3090.designPattern.demo04.before;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Rtx3090SafetyDoor
    * @createTime 2021年09月08日 09:36:00
    * @Description Rtx3090品牌安全门
    */
   public class Rtx3090SafetyDoor implements SafetyDoor{
       @Override
       public void antiTheft() {
           System.out.println("防盗");
       }
   
       @Override
       public void fireProof() {
           System.out.println("防火");
       }
   
       @Override
       public void waterProof() {
           System.out.println("防水");
       }
   }
   ```

4. 安全门测试类

   ```java
   package xyz.rtx3090.designPattern.demo04.before;
   
   import org.junit.jupiter.api.Test;
   
   class Rtx3090SafetyDoorTest {
   
       @Test
       public void testSafetyDoor() {
           Rtx3090SafetyDoor rtx3090SafetyDoor = new Rtx3090SafetyDoor();
           rtx3090SafetyDoor.antiTheft();
           rtx3090SafetyDoor.fireProof();
           rtx3090SafetyDoor.waterProof();
       }
   }
   ```

上面的设计我们发现了它存在的问题，rtx3090品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个rtx3090TI品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/接口隔离原则1.png)

**改进案例演示**

> 此案例是对上一个`案例演示`的改进, 改进原则和思路,在上次项目结尾已有说明

1. 最终项目目录结构,如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908100225.png)

2. 防盗接口

   ```java
   package xyz.rtx3090.designPattern.demo04.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AntiTheft
    * @createTime 2021年09月08日 09:47:00
    * @Description 防盗接口
    */
   public interface AntiTheft {
       //防盗
       void antiTheft();
   }
   ```

3. 防火接口

   ```java
   package xyz.rtx3090.designPattern.demo04.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName FireProof
    * @createTime 2021年09月08日 09:48:00
    * @Description 防火接口
    */
   public interface FireProof {
       //防火
       void fireProof();
   }
   ```

4. 防水接口

   ```java
   package xyz.rtx3090.designPattern.demo04.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName WaterProof
    * @createTime 2021年09月08日 09:48:00
    * @Description 防水接口
    */
   public interface WaterProof {
       //防水
       void waterProof();
   }
   ```

5. Rtx3090品牌安全门

   ```java
   package xyz.rtx3090.designPattern.demo04.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Rtx3090SafetyDoor
    * @createTime 2021年09月08日 09:50:00
    * @Description Rtx3090品牌安全门
    */
   public class Rtx3090SafetyDoor implements AntiTheft, FireProof, WaterProof{
       @Override
       public void antiTheft() {
           System.out.println("防盗");
       }
   
       @Override
       public void fireProof() {
           System.out.println("防火");
       }
   
       @Override
       public void waterProof() {
           System.out.println("防水");
       }
   }
   ```

6. Rtx3090TI安全门

   ```java
   package xyz.rtx3090.designPattern.demo04.after;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Rtx3090TISafetyDoor
    * @createTime 2021年09月08日 09:57:00
    * @Description Rtx3090TI安全门
    */
   public class Rtx3090TISafetyDoor implements AntiTheft, FireProof{
       @Override
       public void antiTheft() {
           System.out.println("防盗");
       }
   
       @Override
       public void fireProof() {
           System.out.println("防火");
       }
   }
   ```

7. 安全门测试类

   ```java
   package xyz.rtx3090.designPattern.demo04.after;
   
   import org.junit.jupiter.api.Test;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName SafetyDoorTest
    * @createTime 2021年09月08日 09:53:00
    * @Description 测试安全门
    */
   public class SafetyDoorTest {
       /**
        * @title 测试rtx3090品牌的防盗门
        * @author BernardoLi
        * @updateTime 2021/9/8 09:54
        * @throws
        * @description rtx3090品牌防盗门有防盗、防火、防水三种功能
        */
       @Test
       public void testRtx3090SafetyDoor() {
           Rtx3090SafetyDoor rtx3090SafetyDoor = new Rtx3090SafetyDoor();
           rtx3090SafetyDoor.antiTheft();
           rtx3090SafetyDoor.fireProof();
           rtx3090SafetyDoor.waterProof();
       }
   
       /**
        * @title 测试rtx3090ti品牌的安全门
        * @author BernardoLi
        * @updateTime 2021/9/8 09:59
        * @throws
        * @description rtx3090ti品牌防盗门有防盗、防火两种功能
        */
       @Test
       public void testRtx3090TISafetyDoor() {
           Rtx3090TISafetyDoor rtx3090TISafetyDoor = new Rtx3090TISafetyDoor();
           rtx3090TISafetyDoor.antiTheft();
           rtx3090TISafetyDoor.fireProof();
       }
   }
   ```

## 3.5 迪米特法则

迪米特法则又叫最少知识原则。

只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。

其含义是：**如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。**

迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

下面看一个例子来理解迪米特法则

【例】明星与经纪人的关系实例

明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。

类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/迪米特法则.png)

**案例演示**

1. 最终项目目录结构,如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908105050.png)

2. 明星类

   ```java
   package xyz.rtx3090.designPattern.demo05;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Star
    * @createTime 2021年09月08日 10:11:00
    * @Description 明星类
    */
   public class Star {
       private String name;
   
       //setter and getter
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   }
   ```

3. 粉丝类

   ```java
   package xyz.rtx3090.designPattern.demo05;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Fans
    * @createTime 2021年09月08日 10:11:00
    * @Description 粉丝类
    */
   public class Fans {
       private String name;
   
       //setter and getter
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   }
   ```

4. 媒体公司类

   ```java
   package xyz.rtx3090.designPattern.demo05;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Company
    * @createTime 2021年09月08日 10:12:00
    * @Description 媒体公司类
    */
   public class Company {
       private String name;
   
       //setter and getter
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   }
   ```

5. 经纪人

   ```java
   package xyz.rtx3090.designPattern.demo05;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Agent
    * @createTime 2021年09月08日 10:13:00
    * @Description 经纪人
    */
   public class Agent {
       private Star star;
       private Fans fans;
       private Company company;
   
       //setter and getter
       public Star getStar() {
           return star;
       }
   
       public void setStar(Star star) {
           this.star = star;
       }
   
       public Fans getFans() {
           return fans;
       }
   
       public void setFans(Fans fans) {
           this.fans = fans;
       }
   
       public Company getCompany() {
           return company;
       }
   
       public void setCompany(Company company) {
           this.company = company;
       }
   
       //和粉丝见面的方法
       public void meeting() {
           System.out.println(star.getName() + "和粉丝" +  fans.getName() + "见面 ");
       }
   
       //和媒体公司洽谈的方法
       public void business() {
           System.out.println(star.getName() + "和公司" + company.getName() + "洽谈");
       }
   }
   ```

6. 测试类

   ```java
   package xyz.rtx3090.designPattern.demo05;
   
   import org.junit.jupiter.api.Test;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AgentTest
    * @createTime 2021年09月08日 10:39:00
    * @Description TODO
    */
   public class AgentTest {
   
       @Test
       public void testAgent() {
           //创建经纪人类
           Agent agent = new Agent();
   
           //创建明星对象
           Star star = new Star();
           star.setName("Justin Bieber");
   
           //创建粉丝对象
           Fans fans = new Fans();
           fans.setName("王多余");
   
           //创建媒体公司对象
           Company company = new Company();
           company.setName("索尼娱乐公司");
   
           //经纪人管理艺人事务
           agent.setStar(star);
           agent.setFans(fans);
           agent.setCompany(company);
   
           //和粉丝见面
           agent.meeting();
           //和媒体公司洽谈业务
           agent.business();
   
       }
   }
   ```

## 3.6 合成复用原则

**合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。**

通常类的复用分为继承复用和合成复用两种。

继承复用虽然有简单和易实现的优点，但它也存在以下缺点：

1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。


采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：

1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 对象间的耦合度低。可以在类的成员位置声明抽象。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

下面看一个例子来理解合成复用原则

【例】汽车分类管理程序

汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： 

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/合成复用原则.png)

从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/合成复用原则1.png)

采用聚合复用就不会出现继承复用的问题, 出现一种新的动力源汽车或者新颜色的话,只要新添加一个动力源子类,而不需要重复添加颜色子类.因为颜色类是动力源子类的一种属性

# 4，创建者模式

创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。

这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。

创建型模式分为：

* 单例模式
* 工厂方法模式
* 抽象工程模式
* 原型模式
* 建造者模式

## 4.1 单例设计模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

### 4.1.1 单例模式的结构

单例模式的主要有以下角色：

* 单例类。只能创建一个实例的类
* 访问类。使用单例类

### 4.1.2 单例模式的实现

> 单例设计模式分类两种：
>
> + 饿汉式：类加载就会导致该单实例对象被创建	
> + 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建

**饿汉式-方式1（静态变量方式）案例演示**

1. 最终项目目录结构,如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908121433.png)

2. 单例类

   ```java
   package xyz.rtx3090.pattern.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Singleton
    * @createTime 2021年09月08日 11:18:00
    * @Description 单例类（饿汉式：静态成员变量）
    */
   public class Singleton {
       //1.所有构造方法
       private Singleton(){};
   
       //2.在本类中创建本类对象
       private static Singleton instance = new Singleton();
   
       //3.提供一个公共的访问方式，让外界获取该对象
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

3. 测试单例模式类

   ```java
   package xyz.rtx3090.pattern.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName SingletonTest
    * @createTime 2021年09月08日 11:31:00
    * @Description 测试单例模式
    */
   public class Client {
       public static void main(String[] args) {
           //创建Singleton类的对象
           Singleton instance1 = Singleton.getInstance();
   
           //再次创建获取Singleton类的对象
           Singleton instance2 = Singleton.getInstance();
   
           //判断两次获取的Singleton类对象是否为同一个对象
           boolean result = (instance1 == instance2);
           System.out.println(result ? "为同一个对象" : "不为同一个对象");
       }
   }
   ```

**饿汉式-方式2（静态代码块方式）案例演示**

1. 最终项目目录结构,如图所示:

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908121822.png)

2. 单例类

   ```java
   package xyz.rtx3090.pattern.demo02;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Singleton
    * @createTime 2021年09月08日 12:02:00
    * @Description 单例类（饿汉式：静态代码块）
    */
   public class Singleton {
       //私有构造方法
       private Singleton(){};
   
       //声明Singleton类型的变量
       private static Singleton instance;
   
       //在静态代码块中对变量进行赋值
       static {
           instance = new Singleton();
       }
   
       //对外提供获取该类对象的方法
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

3. 测试单例模式类

   ```java
   package xyz.rtx3090.pattern.demo02;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月08日 12:06:00
    * @Description 测试单例模式
    */
   public class Client {
       public static void main(String[] args) {
           //获取Singleton对象
           Singleton instance1 = Singleton.getInstance();
   
           //再次获取Singleton对象
           Singleton instance2 = Singleton.getInstance();
   
           //判断两次获取的Singleton对象是否为同一个对象
           boolean result = (instance1 == instance2);
           System.out.println(result ? "为同一个对象" : "不为同一个对象");
       }
   }
   ```

该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。

**饿汉式-方式3（枚举方式）案例演示**

枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。

```java
package xyz.rtx3090.pattern.demo06;

/**
 * @author BernardoLi
 * @version 1.0.0
 * @ClassName Singleton
 * @createTime 2021年09月08日 16:42:00
 * @Description 单例枚举类（枚举实现方式）
 */
public enum Singleton {
    INSTANCE;
}

```

枚举方式只有一个缺点，这个缺点也是“饿汉式”的通病——可能会浪费内存！如果不考虑内存浪费的问题话，枚举方式是首先需要考虑使用的“单例模式”。

**懒汉式-方式1（线程不安全）案例演示**

```java
package xyz.rtx3090.pattern.demo03;

/**
 * @author BernardoLi
 * @version 1.0.0
 * @ClassName Singleton
 * @createTime 2021年09月08日 12:20:00
 * @Description 单例类（懒汉式）
 */
public class Singleton {
    //私有构造方法
    private Singleton() {};

    //声明Singleton类型的变量
    private static Singleton instance;

    //对外提供访问方式
    public static Singleton getInstance() {
        /**
         * 判断instance是否为null
         * 为null，则创建一个新建的Singleton对象，并返回
         * 不为null，则直接返回之前创建好的
         */
        if (instance == null) {
            //如果不加synchronized，多线程会出现问题
            instance = new Singleton();
        }
        return instance;
    }
}
```

从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。

**懒汉式-方式2（线程安全）案例演示**

```java
package xyz.rtx3090.pattern.demo03;

/**
 * @author BernardoLi
 * @version 1.0.0
 * @ClassName Singleton
 * @createTime 2021年09月08日 12:20:00
 * @Description 单例类（懒汉式）
 */
public class Singleton {
    //私有构造方法
    private Singleton() {};

    //声明Singleton类型的变量
    private static Singleton instance;

    //对外提供访问方式(这里增加了synchronized关键字)
    public static synchronized Singleton getInstance() {
        /**
         * 判断instance是否为null
         * 为null，则创建一个新建的Singleton对象，并返回
         * 不为null，则直接返回之前创建好的
         */
        if (instance == null) {
            //如果不加synchronized，多线程会出现问题
            instance = new Singleton();
        }
        return instance;
    }
}
```

该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。

**懒汉式-方式3（双重检查锁）案例演示**

再来讨论一下懒汉模式中加锁的问题，对于 `getInstance()` 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式

```java
package xyz.rtx3090.pattern.demo04;

/**
 * @author BernardoLi
 * @version 1.0.0
 * @ClassName Singleton
 * @createTime 2021年09月08日 16:17:00
 * @Description 单例类（双重检查锁方式）
 */
public class Singleton {
    //私有构造方法
    private Singleton(){};

    //声明Singleton类型的变量
    private static Singleton instance;

    //对外提供公共的访问方式
    public static Singleton getInstance() {
        //第一次判断,如果instance的值不为null，那么不需要抢占锁，直接返回对象
        if (instance == null) {
            synchronized (Singleton.class) {
                //第二次判断,如果instance的值为null，则创建新的Singleton对象
                //如果instance的值不为null，则直接返回已有的Singleton对象
                if (instance == null) {
                    instance = new Singleton();
                }
                return instance;
            }
        }
        return instance;
    }
}
```

双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。

要解决双重检查锁模式带来空指针异常的问题，只需要使用 `volatile` 关键字, `volatile` 关键字可以保证可见性和有序性。

```java
package xyz.rtx3090.pattern.demo04;

/**
 * @author BernardoLi
 * @version 1.0.0
 * @ClassName Singleton
 * @createTime 2021年09月08日 16:17:00
 * @Description 单例类（双重检查锁方式）
 */
public class Singleton {
    //私有构造方法
    private Singleton(){};

    //声明Singleton类型的变量(这里增加了volatile关键字)
    private static volatile Singleton instance;

    //对外提供公共的访问方式
    public static Singleton getInstance() {
        //第一次判断,如果instance的值不为null，那么不需要抢占锁，直接返回对象
        if (instance == null) {
            synchronized (Singleton.class) {
                //第二次判断,如果instance的值为null，则创建新的Singleton对象
                //如果instance的值不为null，则直接返回已有的Singleton对象
                if (instance == null) {
                    instance = new Singleton();
                }
                return instance;
            }
        }
        return instance;
    }
}
```

添加 `volatile` 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。

**懒汉式-方式4（静态内部类方式）案例演示**

静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 `static` 修饰，保证只被实例化一次，并且严格保证实例化顺序。

```java
package xyz.rtx3090.pattern.demo05;

/**
 * @author BernardoLi
 * @version 1.0.0
 * @ClassName Singleton
 * @createTime 2021年09月08日 16:33:00
 * @Description 单例类（静态内部类方式）
 */
public class Singleton {
    //私有构造方法
    private Singleton() {};

    //定义一个静态内部类
    private static class SingletonHolder {
        //在内部类中声明并初始化外部类的对象
        private static Singleton INSTANCE = new Singleton();
    }
    //提供公共的访问方式
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder.

并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。

静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。

### 4.1.3 存在的问题

#### 4.1.3.1 问题演示

破坏单例模式：

使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。

**序列化、反序列化破坏单例模式 案例演示**

1. 单例类

   ```java
   package xyz.rtx3090.pattern.demo07;
   
   import java.io.Serializable;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Singleton
    * @createTime 2021年09月08日 16:51:00
    * @Description 单例类（静态内部类方式）
    */
   public class Singleton implements Serializable {
       //私有构造方法
       private Singleton() {};
   
       //定义一个静态内部类
       private static class SingletonHolder {
           //在内部类中声明并初始化外部类的对象
           private static Singleton INSTANCE = new Singleton();
       }
       //提供公共的访问方式
       public static Singleton getInstance() {
           return SingletonHolder.INSTANCE;
       }
   }
   ```

2. 测试类

   ```java
   package xyz.rtx3090.pattern.demo07;
   
   import java.io.*;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月08日 16:52:00
    * @Description 使用序列化、反序列化破坏单例模式
    */
   public class Client {
       public static void main(String[] args) throws IOException, ClassNotFoundException {
           writeObjectToFile();
           readObjectFromFile();
           readObjectFromFile();
       }
   
       //向文件中写数据（对象）
       public static void writeObjectToFile() throws IOException {
           //1.获取Singleton对象
           Singleton instance = Singleton.getInstance();
           //2.创建输出流对象
           ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("/Users/bernardo/Downloads/test.text"));
           //3.写对象
           objectOutputStream.writeObject(instance);
           //4.释放资源
           objectOutputStream.close();
       }
   
       //从文件中读取数据（对象）
       public static void readObjectFromFile() throws IOException, ClassNotFoundException {
           //1.创建输入流对象
           ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("/Users/bernardo/Downloads/test.text"));
           //2.读取对象
           Singleton instance = (Singleton) objectInputStream.readObject();
           //3.打印
           System.out.println("读取到的对象："+instance);
           //4.释放资源
           objectInputStream.close();
       }
   }
   ```

上面代码运行两次打印的结果不同，表明序列化和反序列化已经破坏了单例设计模式。

**反射破坏单例模式 案例演示**

1. 单例类

   ```java
   package xyz.rtx3090.pattern.demo08;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Singleton
    * @createTime 2021年09月08日 17:10:00
    * @Description 单例类（静态内部类方式）
    */
   public class Singleton {
       //私有构造方法
       private Singleton() {};
   
       //定义一个静态内部类
       private static class SingletonHolder {
           //在内部类中声明并初始化外部类的对象
           private static Singleton INSTANCE = new Singleton();
       }
       //提供公共的访问方式
       public static Singleton getInstance() {
           return SingletonHolder.INSTANCE;
       }
   }
   ```

2. 测试类

   ```java
   package xyz.rtx3090.pattern.demo08;
   
   import java.lang.reflect.Constructor;
   import java.lang.reflect.InvocationTargetException;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月08日 17:11:00
    * @Description 使用反射破坏单例模式
    */
   public class Client {
       public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
           //1.获取Singleton的字节码对象
           Class cla = Singleton.class;
           //2.获取无参构造方法对象
           Constructor cons = cla.getDeclaredConstructor();
           //3.取消访问检查
           cons.setAccessible(true);
           //4.创建Singleton对象
            Singleton instance1 = (Singleton) cons.newInstance();
            Singleton instance2 = (Singleton) cons.newInstance();
            //5.判断获取的两个对象是否相同
           boolean result = (instance1 == instance2);
           System.out.println(result ? "相同" : "不相同");
       }
   }
   ```

上面代码运行结果是`不相同`，表明序列化和反序列化已经破坏了单例设计模式

#### 4.1.3.2 问题的解决

**序列化、反序列方式破坏单例模式的解决方法**

在Singleton类中添加`readResolve()`方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。

**单例类**

```java
package xyz.rtx3090.pattern.demo08;

/**
 * @author BernardoLi
 * @version 1.0.0
 * @ClassName Singleton
 * @createTime 2021年09月08日 17:10:00
 * @Description 单例类（静态内部类方式）
 */
public class Singleton {
    private static boolean flag = false;

    //私有构造方法
    private Singleton() {
        synchronized (Singleton.class) {
            //判断flag的值是否为true，若为true，则为第一次访问，直接抛异常
            //若为false，则说明不是第一次访问
            if (flag) {
                throw new RuntimeException("不能创建多个对象");
            }
            //将flag值设置为true
            flag = true;
        }
    };

    //定义一个静态内部类
    private static class SingletonHolder {
        //在内部类中声明并初始化外部类的对象
        private static Singleton INSTANCE = new Singleton();
    }
    //提供公共的访问方式
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**源码解析**

```java
public final Object readObject() throws IOException, ClassNotFoundException{
      ...
      // if nested read, passHandle contains handle of enclosing object
      int outerHandle = passHandle;
      try {
          Object obj = readObject0(false);//重点查看readObject0方法
      .....
  }
      
  private Object readObject0(boolean unshared) throws IOException {
  	...
      try {
  		switch (tc) {
  			...
  			case TC_OBJECT:
  				return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法
  			...
          }
      } finally {
          depth--;
          bin.setBlockDataMode(oldMode);
      }    
  }
      
  private Object readOrdinaryObject(boolean unshared) throws IOException {
  	...
  	//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，
      obj = desc.isInstantiable() ? desc.newInstance() : null; 
      ...
      // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true
      if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) {
      	// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量
      	// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。
      	Object rep = desc.invokeReadResolve(obj);
       	...
      }
      return obj;
  }
```

**反射方式破解单例的解决方法**

```java
public class Singleton {
  
      //私有构造方法
      private Singleton() {
          /*
             反射破解单例模式需要添加的代码
          */
          if(instance != null) {
              throw new RuntimeException();
          }
      }
      
      private static volatile Singleton instance;
  
      //对外提供静态方法获取该对象
      public static Singleton getInstance() {
  
          if(instance != null) {
              return instance;
          }
  
          synchronized (Singleton.class) {
              if(instance != null) {
                  return instance;
              }
              instance = new Singleton();
              return instance;
          }
      }
  }
```

这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。

### 4.1.4 JDK源码解析-Runtime类

Runtime类就是使用的单例设计模式。

1. 通过源代码查看使用的是哪儿种单例模式

   ```java
      public class Runtime {
          private static Runtime currentRuntime = new Runtime();
      
          /**
           * Returns the runtime object associated with the current Java application.
           * Most of the methods of class <code>Runtime</code> are instance
           * methods and must be invoked with respect to the current runtime object.
           *
           * @return  the <code>Runtime</code> object associated with the current
           *          Java application.
           */
          public static Runtime getRuntime() {
              return currentRuntime;
          }
      
          /** Don't let anyone else instantiate this class */
          private Runtime() {}
          ...
      }
   ```

    从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。

2. 使用Runtime类中的方法

      ```java
      public class RuntimeDemo {
          public static void main(String[] args) throws IOException {
              //获取Runtime类对象
              Runtime runtime = Runtime.getRuntime();
      
              //返回 Java 虚拟机中的内存总量。
              System.out.println(runtime.totalMemory());
              //返回 Java 虚拟机试图使用的最大内存量。
              System.out.println(runtime.maxMemory());
      
              //创建一个新的进程执行指定的字符串命令，返回进程对象
              Process process = runtime.exec("ipconfig");
              //获取命令执行后的结果，通过输入流获取
              InputStream inputStream = process.getInputStream();
              byte[] arr = new byte[1024 * 1024* 100];
              int b = inputStream.read(arr);
              System.out.println(new String(arr,0,b,"gbk"));
          }
      } 
      ```

## 4.2 工厂模式

### 4.2.1 概述

需求：设计一个咖啡店点餐系统。  

设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。

具体类的设计如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/工厂设计模式引入.png)

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908191415.png)

2. 咖啡抽象类

   ```java
   package xyz.rtx3090.pattern.factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Coffee
    * @createTime 2021年09月08日 18:55:00
    * @Description 咖啡抽象类
    */
   public abstract class Coffee {
   
       public abstract String getName();
   
       //加糖
       public void addSugar() {
           System.out.println("加糖");
       }
   
       //加奶
       public void addMilk() {
           System.out.println("加奶");
       }
   }
   ```

3. 美式咖啡类

   ```java
   package xyz.rtx3090.pattern.factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AmericanCoffee
    * @createTime 2021年09月08日 18:57:00
    * @Description 美式咖啡
    */
   public class AmericanCoffee extends Coffee{
       @Override
       public String getName() {
           return "美式咖啡";
       }
   }
   ```

4. 拿铁咖啡

   ```java
   package xyz.rtx3090.pattern.factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName LatteCoffee
    * @createTime 2021年09月08日 18:58:00
    * @Description 拿铁咖啡
    */
   public class LatteCoffee extends Coffee{
       @Override
       public String getName() {
           return "拿铁咖啡";
       }
   }
   ```

5. 咖啡店类

   ```java
   package xyz.rtx3090.pattern.factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName CoffeeStore
    * @createTime 2021年09月08日 18:59:00
    * @Description 咖啡店
    */
   public class CoffeeStore {
       public Coffee orderCoffee(String type) {
           //声明Coffee类的变量，根据不同类型创建不同的Coffee子类对象
           Coffee coffee = null;
           if ("american".equals(type)) {
               coffee = new AmericanCoffee();
           } else if ("latte".equals(type)) {
               coffee = new LatteCoffee();
           } else {
               throw new RuntimeException("对不起，您所点的咖啡没有");
           }
           //加糖、加奶
           coffee.addSugar();
           coffee.addMilk();
   
           return coffee;
       }
   }
   ```

6. 测试类

   ```java
   package xyz.rtx3090.pattern.factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月08日 19:02:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) {
           //1.创建咖啡店类
           CoffeeStore store = new CoffeeStore();
           //2.点咖啡
           Coffee coffee = store.orderCoffee("american");
   
           System.out.println(coffee.getName());
       }
   }
   ```

在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：**解耦**。

在本教程中会介绍三种工厂的使用

* 简单工厂模式（不属于GOF的23种经典设计模式）
* 工厂方法模式
* 抽象工厂模式

### 4.2.2 简单工厂模式

简单工厂不是一种设计模式，反而比较像是一种编程习惯。

#### 4.2.2.1 结构

简单工厂包含如下角色：

* 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。
* 具体产品 ：实现或者继承抽象产品的子类
* 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。

#### 4.2.2.2 实现

现在使用简单工厂对上面案例进行改进，类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/简单工厂模式.png)

**简单工厂模式案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210908223130.png)

2. 咖啡抽象类

   ```java
   package xyz.rtx3090.pattern.simpleFactory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Coffee
    * @createTime 2021年09月08日 17:24:00
    * @Description 咖啡抽象类
    */
   public abstract class Coffee {
   
       public abstract String getName();
   
       //加糖
       public void addSugar() {
           System.out.println("加糖");
       }
   
       //加奶
       public void addMilk() {
           System.out.println("加奶");
       }
   }
   ```

3. 美式咖啡

   ```java
   package xyz.rtx3090.pattern.simpleFactory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AmericanCoffee
    * @createTime 2021年09月08日 17:25:00
    * @Description 美式咖啡
    */
   public class AmericanCoffee extends Coffee {
       @Override
       public String getName() {
           return "美式咖啡";
       }
   }
   ```

4. 拿铁咖啡

   ```java
   package xyz.rtx3090.pattern.simpleFactory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName LatteCoffee
    * @createTime 2021年09月08日 17:23:00
    * @Description 拿铁咖啡
    */
   public class LatteCoffee extends Coffee {
       @Override
       public String getName() {
           return "拿铁咖啡";
       }
   }
   ```

5. 咖啡店

   ```java
   package xyz.rtx3090.pattern.simpleFactory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName CoffeeStore
    * @createTime 2021年09月08日 19:26:00
    * @Description 咖啡店
    */
   public class CoffeeStore {
       public Coffee orderCoffee(String type) {
           SimpleCoffeeFactory factory = new SimpleCoffeeFactory();
           //调用生产咖啡的方法
           Coffee coffee = factory.createCoffee(type);
           //加糖、加奶
           coffee.addSugar();
           coffee.addMilk();
   
           return coffee;
       }
   }
   ```

6. 简单咖啡工厂类

   ```java
   package xyz.rtx3090.pattern.simpleFactory;
   
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName SimpleCoffeeFactory
    * @createTime 2021年09月08日 19:26:00
    * @Description 简单咖啡工厂类
    */
   public class SimpleCoffeeFactory {
       public static Coffee createCoffee(String type) {
           //声明Coffee类的变量，根据不同类型创建不同的Coffee子类对象
           Coffee coffee = null;
           if ("american".equals(type)) {
               coffee = new AmericanCoffee();
           } else if ("latte".equals(type)) {
               coffee = new LatteCoffee();
           } else {
               throw new RuntimeException("对不起，您所点的咖啡没有");
           }
   
           return coffee;
       }
   }
   ```

7. 测试类

   ```java
   package xyz.rtx3090.pattern.simpleFactory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月08日 19:32:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) {
           //创建咖啡店类对象
           CoffeeStore coffeeStore = new CoffeeStore();
           //创建咖啡对象
           Coffee americanCoffee = coffeeStore.orderCoffee("american");
   
           System.out.println(americanCoffee.getName());
       }
   }
   ```

工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。

后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。

#### 4.2.2.4 优缺点

**优点：**

封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。

**缺点：**

增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。

#### 4.2.2.3 扩展

**静态工厂**

在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：

```java
public class SimpleCoffeeFactory {

    public static Coffee createCoffee(String type) {
        Coffee coffee = null;
        if("americano".equals(type)) {
            coffee = new AmericanoCoffee();
        } else if("latte".equals(type)) {
            coffee = new LatteCoffee();
        }
        return coffe;
    }
}
```

### 4.2.3 工厂方法模式

针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。

#### 4.2.3.1 概念

定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。

#### 4.2.3.2 结构

工厂方法模式的主要角色：

* 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
* 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

#### 4.2.3.3 实现

使用工厂方法模式对上例进行改进，类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/工厂方法模式.png)

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210909002904.png)

2. 咖啡抽象类

   ```java
   package xyz.rtx3090.pattern.factoryMethod;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Coffee
    * @createTime 2021年09月08日 18:55:00
    * @Description 咖啡抽象类
    */
   public abstract class Coffee {
   
       public abstract String getName();
   
       //加糖
       public void addSugar() {
           System.out.println("加糖");
       }
   
       //加奶
       public void addMilk() {
           System.out.println("加奶");
       }
   }
   ```

3. 美式咖啡

   ```java
   package xyz.rtx3090.pattern.factoryMethod;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AmericanCoffee
    * @createTime 2021年09月08日 18:57:00
    * @Description 美式咖啡
    */
   public class AmericanCoffee extends Coffee {
       @Override
       public String getName() {
           return "美式咖啡";
       }
   }
   ```

4. 拿铁咖啡

   ```java
   package xyz.rtx3090.pattern.factoryMethod;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName LatteCoffee
    * @createTime 2021年09月08日 18:58:00
    * @Description 拿铁咖啡
    */
   public class LatteCoffee extends Coffee {
       @Override
       public String getName() {
           return "拿铁咖啡";
       }
   }
   ```

5. 咖啡抽象工厂

   ```java
   package xyz.rtx3090.pattern.factoryMethod;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName CoffeeFactory
    * @createTime 2021年09月08日 19:48:00
    * @Description 咖啡抽象工厂
    */
   public interface CoffeeFactory {
       //创建咖啡对象的方法
       Coffee createCoffee();
   }
   ```

6. 美式咖啡工厂

   ```java
   package xyz.rtx3090.pattern.factoryMethod;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AmericanCoffeeFactory
    * @createTime 2021年09月08日 22:36:00
    * @Description 美式咖啡工厂
    */
   public class AmericanCoffeeFactory implements CoffeeFactory{
       @Override
       public Coffee createCoffee() {
           return new AmericanCoffee();
       }
   }
   ```

7. 拿铁咖啡工厂

   ```java
   package xyz.rtx3090.pattern.factoryMethod;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName LatteCoffeeFactory
    * @createTime 2021年09月08日 22:38:00
    * @Description 拿铁咖啡工厂
    */
   public class LatteCoffeeFactory implements CoffeeFactory{
       @Override
       public Coffee createCoffee() {
           return new LatteCoffee();
       }
   }
   ```

8. 咖啡店

   ```java
   package xyz.rtx3090.pattern.factoryMethod;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName CoffeeStore
    * @createTime 2021年09月08日 18:59:00
    * @Description 咖啡店
    */
   public class CoffeeStore {
   
       private CoffeeFactory factory;
   
       public void setFactory(CoffeeFactory factory) {
           this.factory = factory;
       }
   
       //点咖啡功能
       public Coffee orderCoffee() {
           Coffee coffee = factory.createCoffee();
           //加配料
           coffee.addMilk();
           coffee.addSugar();
           return coffee;
       }
   }
   ```

9. 测试类

   ```java
   package xyz.rtx3090.pattern.factoryMethod;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月08日 23:01:00
    * @Description TODO
    */
   public class Client {
       public static void main(String[] args) {
           //创建咖啡店对象
           CoffeeStore coffeeStore = new CoffeeStore();
           //创建工厂对象
           CoffeeFactory americanCoffeeFactory = new AmericanCoffeeFactory();
           //签订工厂
           coffeeStore.setFactory(americanCoffeeFactory);
           //点咖啡
           Coffee coffee = coffeeStore.orderCoffee();
           System.out.println(coffee.getName());
   
           System.out.println("--------------------------------");
   
           //创建工厂对象
           LatteCoffeeFactory latteCoffeeFactory = new LatteCoffeeFactory();
           //签订工厂
           coffeeStore.setFactory(latteCoffeeFactory);
           //点咖啡
           Coffee coffee1 = coffeeStore.orderCoffee();
           System.out.println(coffee1.getName());
       }
   }
   ```

从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。

工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。

#### 4.2.3.4 优缺点

**优点：**

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
- 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；

**缺点：**

* 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。

### 4.2.4 抽象工厂模式

前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。

这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。

本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/image-20200401214509176.png)

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/image-20200401222951963.png)

#### 4.2.4.1 概念

是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

#### 4.2.4.2 结构

抽象工厂模式的主要角色如下：

* 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。
* 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。

#### 4.2.4.2 实现

现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/抽象工厂模式.png)

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210909063913.png)

2. 咖啡抽象类

   ```java
   package xyz.rtx3090.pattern.abstract_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Coffee
    * @createTime 2021年09月08日 18:55:00
    * @Description 咖啡抽象类
    */
   public abstract class Coffee {
   
       public abstract String getName();
   
       //加糖
       public void addSugar() {
           System.out.println("加糖");
       }
   
       //加奶
       public void addMilk() {
           System.out.println("加奶");
       }
   }
   ```

3. 拿铁咖啡

   ```java
   package xyz.rtx3090.pattern.abstract_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName LatteCoffee
    * @createTime 2021年09月08日 18:58:00
    * @Description 拿铁咖啡
    */
   public class LatteCoffee extends Coffee {
       @Override
       public String getName() {
           return "拿铁咖啡";
       }
   }
   ```

4. 美式咖啡

   ```java
   package xyz.rtx3090.pattern.abstract_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AmericanCoffee
    * @createTime 2021年09月08日 18:57:00
    * @Description 美式咖啡
    */
   public class AmericanCoffee extends Coffee {
       @Override
       public String getName() {
           return "美式咖啡";
       }
   }
   ```

5. 甜品抽象类

   ```java
   package xyz.rtx3090.pattern.abstract_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Dessert
    * @createTime 2021年09月09日 06:10:00
    * @Description 甜品抽象类
    */
   public abstract class Dessert {
       public abstract void show();
   }
   ```

6. 提拉米苏类

   ```java
   package xyz.rtx3090.pattern.abstract_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Trimisu
    * @createTime 2021年09月09日 06:12:00
    * @Description 提拉米苏类
    */
   public class Trimisu extends Dessert{
       @Override
       public void show() {
           System.out.println("提拉米苏");
       }
   }
   ```

7. 抹茶慕斯类

   ```java
   package xyz.rtx3090.pattern.abstract_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName MatchaMousse
    * @createTime 2021年09月09日 06:13:00
    * @Description 抹茶慕斯类
    */
   public class MatchaMousse extends Dessert{
       @Override
       public void show() {
           System.out.println("抹茶慕斯");
       }
   }
   ```

8. 甜品工厂接口

   ```java
   package xyz.rtx3090.pattern.abstract_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName DessertFactory
    * @createTime 2021年09月09日 06:15:00
    * @Description 甜品工厂接口
    */
   public interface DessertFactory {
   
       //生产咖啡的功能
       Coffee createCoffee();
   
       //生产甜品的功能
       Dessert createDessert();
   }
   ```

9. 意大利风味甜品工厂

   ```java
   package xyz.rtx3090.pattern.abstract_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName ItalyDessertFactory
    * @createTime 2021年09月09日 06:20:00
    * @Description 意大利风味甜品工厂
    *              生产拿铁咖啡、提拉米苏
    */
   public class ItalyDessertFactory implements DessertFactory{
       //生产拿铁咖啡
       @Override
       public Coffee createCoffee() {
           return new LatteCoffee();
       }
   
       //生产提拉米苏
       @Override
       public Dessert createDessert() {
           return new Trimisu();
       }
   }
   ```

10. 美式风味甜品工厂类

    ```java
    package xyz.rtx3090.pattern.abstract_factory;
    
    /**
     * @author BernardoLi
     * @version 1.0.0
     * @ClassName AmericanDessertFactory
     * @createTime 2021年09月09日 06:17:00
     * @Description 美式风味甜品工厂类
     *              生产美式咖啡、抹茶慕斯
     */
    public class AmericanDessertFactory implements DessertFactory{
        //生产美式咖啡
        @Override
        public Coffee createCoffee() {
            return new AmericanCoffee();
        }
    
        //生产抹茶慕斯
        @Override
        public Dessert createDessert() {
            return new MatchaMousse();
        }
    }
    ```

11. 测试类

    ```java
    package xyz.rtx3090.pattern.abstract_factory;
    
    /**
     * @author BernardoLi
     * @version 1.0.0
     * @ClassName Client
     * @createTime 2021年09月09日 06:23:00
     * @Description 测试类
     */
    public class Client {
        public static void main(String[] args) {
            //创建意大利风味甜品工厂对象
            DessertFactory italyDessertFactory = new ItalyDessertFactory();
            //获取拿铁咖啡和提拉米苏甜品
            Coffee coffee = italyDessertFactory.createCoffee();
            Dessert dessert = italyDessertFactory.createDessert();
    
            System.out.println(coffee.getName());
            dessert.show();
    
            System.out.println("-------------------------------------");
    
            //创建美式风味甜品工厂对象
            DessertFactory americanDessertFactory = new AmericanDessertFactory();
            //获取美式咖啡和抹茶慕斯甜品
            Coffee coffee1 = americanDessertFactory.createCoffee();
            Dessert dessert1 = americanDessertFactory.createDessert();
    
            System.out.println(coffee1.getName());
            dessert1.show();
        }
    }
    ```

如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。

#### 4.2.4.3 优缺点

**优点：**

当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**

当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

#### 4.2.4.4 使用场景

* 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。

* 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。

* 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。

如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。

### 4.2.5 模式扩展

**简单工厂+配置文件解除耦合**

可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。

**案例演示**

1. 定义配置文件

   为了演示方便，我们使用properties文件作为配置文件，名称为`beans.properties`

   ```properties
   american=xyz.rtx3090.pattern.config_factory.AmericanCoffee
   latte=xyz.rtx3090.pattern.config_factory.LatteCoffee
   ```

2. 咖啡抽象类

   ```java
   package xyz.rtx3090.pattern.config_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Coffee
    * @createTime 2021年09月08日 18:55:00
    * @Description 咖啡抽象类
    */
   public abstract class Coffee {
   
       public abstract String getName();
   
       //加糖
       public void addSugar() {
           System.out.println("加糖");
       }
   
       //加奶
       public void addMilk() {
           System.out.println("加奶");
       }
   }
   ```

3. 美式咖啡类

   ```java
   package xyz.rtx3090.pattern.config_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName AmericanCoffee
    * @createTime 2021年09月09日 06:50:00
    * @Description 美式咖啡
    */
   public class AmericanCoffee extends Coffee{
       @Override
       public String getName() {
           return "美式咖啡";
       }
   }
   ```

4. 拿铁咖啡类

   ```java
   package xyz.rtx3090.pattern.config_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName LatteCoffee
    * @createTime 2021年09月09日 06:50:00
    * @Description 拿铁咖啡
    */
   public class LatteCoffee extends Coffee{
       @Override
       public String getName() {
           return "拿铁咖啡";
       }
   }
   ```

5. 咖啡工厂类

   ```java
   package xyz.rtx3090.pattern.config_factory;
   
   import java.io.IOException;
   import java.io.InputStream;
   import java.util.HashMap;
   import java.util.Map;
   import java.util.Properties;
   import java.util.Set;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName CoffeeFactory
    * @createTime 2021年09月09日 06:54:00
    * @Description 咖啡工厂类
    */
   public class CoffeeFactory {
   
       /**
        * 加载配置文件，获取配置文件中配置的全类名，并创建该类对象对象存储
        */
   
       //1. 定义容器对象存储咖啡对象
       private static Map<String, Coffee> map =  new HashMap<>();
   
       //2.加载配置文件（只需要加载一次）
       static {
           //2.1 创建properties对象
           Properties properties = new Properties();
           //2.2 创建properties对象的load方法进行配置文件的加载
           InputStream resourceAsStream = CoffeeFactory.class.getClassLoader().getResourceAsStream("beans.properties");
           try {
               properties.load(resourceAsStream);
               //从properties集合中获取全类名并创建对象
               Set<Object> keys = properties.keySet();
               for (Object key :
                       keys) {
                   String className = properties.getProperty((String) key);
                   //通过反射技术创建对象
                   Class clazz = Class.forName(className);
                   Coffee coffee = (Coffee) clazz.newInstance();
                   //将名称和对象存储到容器中
                   map.put((String) key, coffee);
               }
   
           } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {
               e.printStackTrace();
           }
       }
   
       //根据名称获取对象
       public static Coffee createCoffee(String name) {
           return map.get(name);
       }
   }
   ```

6. 测试类

   ```java
   package xyz.rtx3090.pattern.config_factory;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月09日 07:14:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) {
           Coffee americanCoffee = CoffeeFactory.createCoffee("american");
           System.out.println(americanCoffee.getName());
   
           System.out.println("------------------------");
   
           Coffee latteCoffee = CoffeeFactory.createCoffee("latte");
           System.out.println(latteCoffee.getName());
       }
   }
   ```

静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。

### 4.2.6 JDK源码解析-Collection.iterator方法

```java
public class Demo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("令狐冲");
        list.add("风清扬");
        list.add("任我行");

        //获取迭代器对象
        Iterator<String> it = list.iterator();
        //使用迭代器遍历
        while(it.hasNext()) {
            String ele = it.next();
            System.out.println(ele);
        }
    }
}
```

对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/jdk源码解析.png)

Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。

>补充：
>
>1,DateForamt类中的getInstance()方法使用的是工厂模式；
>
>2,Calendar类中的getInstance()方法使用的是工厂模式；

## 4.3 原型模式

### 4.3.1 概述

用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。

### 4.3.2 结构

原型模式包含如下角色：

* 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。
* 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。
* 访问类：使用具体原型类中的 clone() 方法来复制新的对象。

接口类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/原型模式.png)

### 4.3.3 实现

原型模式的克隆分为浅克隆和深克隆。

+ **浅克隆：**创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
+ **深克隆：**创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

Java中的Object类中提供了 `clone()` 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210909095323.png)

2. 具体的原型类

   ```java
   package xyz.rtx3090.prototype.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Realizetype
    * @createTime 2021年09月09日 09:46:00
    * @Description 具体的原型类
    */
   public class Realizetype implements Cloneable{
       public Realizetype() {
           System.out.println("具体的原型对象创建完成！");
       }
   
       @Override
       protected Realizetype clone() throws CloneNotSupportedException {
           System.out.println("具体原型复制成功！");
           return (Realizetype) super.clone();
       }
   }
   ```

3. 测试类

   ```java
   package xyz.rtx3090.prototype.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月09日 09:48:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) throws CloneNotSupportedException {
           //创建一个原型类对象
           Realizetype realizetype = new Realizetype();
   
           //调用Realizetype类中的clone方法进行对象的克隆
           Realizetype clone = realizetype.clone();
   
           System.out.println("原型对象和克隆出来的是否为同一个对象：" + (realizetype == clone));
       }
   }
   ```

### 4.3.4 案例

**用原型模式生成“三好学生”奖状**

同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/原型模式1.png)

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210909100507.png)

2. 具体的原型奖状类

   ```java
   package xyz.rtx3090.prototype.demo02;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Citation
    * @createTime 2021年09月09日 09:56:00
    * @Description 具体的原型奖状类
    */
   public class Citation implements Cloneable{
   
       //三好学生的姓名
       private String name;
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   
       @Override
       protected Object clone() throws CloneNotSupportedException {
           return super.clone();
       }
   
       public void show() {
           System.out.println(name + "同学：在2020学年第一学期中表现优秀，被评为三好学生，特发此状！");
       }
   }
   ```

3. 测试类

   ```java
   package xyz.rtx3090.prototype.demo02;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月09日 09:59:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) throws CloneNotSupportedException {
           //1.创建原型对象
           Citation citation = new Citation();
           //2.克隆奖状对象
           Citation citation1 = (Citation) citation.clone();
   
           citation.setName("Jason");
           citation1.setName("Bernardo");
   
           //3.调用show方法展示奖状
           citation.show();
           citation1.show();
       }
   }
   ```

### 4.3.5 使用场景

* 对象的创建非常复杂，可以使用原型模式快捷的创建对象。
* 性能和安全要求比较高。

### 4.3.6 扩展（深克隆）

将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210909103110.png)

2. 具体的原型奖状类

   ```java
   package xyz.rtx3090.prototype.demo03;
   
   import java.io.Serializable;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Citation
    * @createTime 2021年09月09日 09:56:00
    * @Description 具体的原型奖状类
    */
   public class Citation implements Cloneable, Serializable {
       
       private Student stu;
   
       //setter and getter
   
       public Student getStu() {
           return stu;
       }
   
       public void setStu(Student stu) {
           this.stu = stu;
       }
   
       @Override
       protected Object clone() throws CloneNotSupportedException {
           return super.clone();
       }
   
       public void show() {
           System.out.println(stu.getName() + "同学：在2020学年第一学期中表现优秀，被评为三好学生，特发此状！");
       }
   }
   ```

3. 学生类

   ```java
   package xyz.rtx3090.prototype.demo03;
   
   import java.io.Serializable;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Student
    * @createTime 2021年09月09日 10:03:00
    * @Description  学生类
    */
   public class Student implements Serializable {
       //学生姓名
       private String name;
   
       //setter and getter
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   
       @Override
       public String toString() {
           return "Student{" +
                   "name='" + name + '\'' +
                   '}';
       }
   }
   ```

4. 测试类

   ```java
   package xyz.rtx3090.prototype.demo03;
   
   import java.io.*;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月09日 09:59:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException {
           //1.创建原型对象
           Citation citation = new Citation();
           //2.创建Jason学生对象
           Student stu = new Student();
           stu.setName("Jason");
           //3.将学生对象赋值为原型对象
           citation.setStu(stu);
           //4.创建对象输出流
           ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("/Users/bernardo/Downloads/a.txt"));
           //5.写对象
           oos.writeObject(citation);
           //6.释放资源
           oos.close();
           //7.创建对象输入流
           ObjectInputStream ois = new ObjectInputStream(new FileInputStream("/Users/bernardo/Downloads/a.txt"));
           //8.读取对象
           Citation citation1 = (Citation) ois.readObject();
           //9.释放资源
           ois.close();
           //10.获取克隆的学生对象
           Student stu1 = citation1.getStu();
           stu1.setName("Bernardo");
           //11.展示对比奖状
           citation.show();
           citation1.show();
       }
   }
   ```

stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。

> 注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。

## 4.5 建造者模式

### 4.4.1 概述

将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/image-20200413225341516.png)

* 分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。
* 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。
* 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。

### 4.4.2 结构

建造者（Builder）模式包含如下角色：

* 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 

* 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 

* 产品类（Product）：要创建的复杂对象。

* 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 

类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/建造者模式.png)

### 4.4.3 实例

**创建共享单车**

生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。

这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/建造者模式1.png)

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210909113526.png)

2. 自行车产品对象

   ```java
   package xyz.rtx3090.builder.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Bike
    * @createTime 2021年09月09日 10:44:00
    * @Description 自行车产品对象
    */
   public class Bike {
       //车架
       private String frame;
       //车座
       private String seat;
   
       //setter and getter
   
       public String getFrame() {
           return frame;
       }
   
       public void setFrame(String frame) {
           this.frame = frame;
       }
   
       public String getSeat() {
           return seat;
       }
   
       public void setSeat(String seat) {
           this.seat = seat;
       }
   }
   ```

3. 构造者类

   ```java
   package xyz.rtx3090.builder.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Builder
    * @createTime 2021年09月09日 10:45:00
    * @Description 构造者类
    */
   public abstract class Builder {
       //声明Bike类型的变量，并进行赋值
       protected Bike bike = new Bike();
   
       public abstract void buildFrame();
   
       public abstract void buildSeat();
   
       //构建自行车的方法
       public abstract Bike createBike();
   }
   ```

4. 

   ```java
   package xyz.rtx3090.builder.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName MobileBuilder
    * @createTime 2021年09月09日 10:59:00
    * @Description 具体的构建者，用来构建摩拜单车对象
    */
   public class MobileBuilder extends Builder{
       @Override
       public void buildFrame() {
           bike.setFrame("碳纤维材质车架");
       }
   
       @Override
       public void buildSeat() {
           bike.setSeat("真皮车座");
       }
   
       @Override
       public Bike createBike() {
           return bike;
       }
   }
   ```

5. 摩拜的构建者，用来构建摩拜单车对象

   ```java
   package xyz.rtx3090.builder.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName MobileBuilder
    * @createTime 2021年09月09日 10:59:00
    * @Description 摩拜的构建者，用来构建摩拜单车对象
    */
   public class MobileBuilder extends Builder{
       @Override
       public void buildFrame() {
           bike.setFrame("碳纤维材质车架");
       }
   
       @Override
       public void buildSeat() {
           bike.setSeat("真皮车座");
       }
   
       @Override
       public Bike createBike() {
           return bike;
       }
   }
   ```

6. ofo单车构建者，用来构建ofo单车

   ```java
   package xyz.rtx3090.builder.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName OfoBuilder
    * @createTime 2021年09月09日 11:00:00
    * @Description ofo单车构建者，用来构建ofo单车
    */
   public class OfoBuilder extends Builder{
   
       @Override
       public void buildFrame() {
           bike.setFrame("铝合金车架");
       }
   
       @Override
       public void buildSeat() {
           bike.setSeat("橡胶车座");
       }
   
       @Override
       public Bike createBike() {
           return bike;
       }
   }
   ```

7. 指挥者类

   ```java
   package xyz.rtx3090.builder.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Director
    * @createTime 2021年09月09日 11:14:00
    * @Description 指挥者类
    */
   public class Director {
       //声明Builder类型的变量
       private Builder builder;
   
       public Director(Builder builder) {
           this.builder = builder;
       }
   
       //组装自行车的功能
       public Bike construct() {
           builder.buildFrame();
           builder.buildSeat();
           return builder.createBike();
       }
   }
   ```

8. 测试类

   ```java
   package xyz.rtx3090.builder.demo01;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月09日 11:19:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) {
           //创建指挥者对象
           Director director = new Director(new MobileBuilder());
           //让指挥者指挥组装自行车
           Bike bike = director.construct();
   
           System.out.println(bike.getFrame());
           System.out.println(bike.getSeat());
       }
   }
   ```

上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合

```java
// 抽象 builder 类
public abstract class Builder {

    protected Bike mBike = new Bike();

    public abstract void buildFrame();
    public abstract void buildSeat();
    public abstract Bike createBike();
    
    public Bike construct() {
        this.buildFrame();
        this.BuildSeat();
        return this.createBike();
    }
}
```

这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。

### 4.4.4 优缺点

**优点：**

- 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
- 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
- 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
- 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。

**缺点：**

造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

### 4.4.5 使用场景

建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。

- 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
- 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。

### 4.4.6 模式扩展

建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。

**重构前代码如下：**

```java
public class Phone {
    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    public Phone(String cpu, String screen, String memory, String mainboard) {
        this.cpu = cpu;
        this.screen = screen;
        this.memory = memory;
        this.mainboard = mainboard;
    }

    public String getCpu() {
        return cpu;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public String getScreen() {
        return screen;
    }

    public void setScreen(String screen) {
        this.screen = screen;
    }

    public String getMemory() {
        return memory;
    }

    public void setMemory(String memory) {
        this.memory = memory;
    }

    public String getMainboard() {
        return mainboard;
    }

    public void setMainboard(String mainboard) {
        this.mainboard = mainboard;
    }

    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", mainboard='" + mainboard + '\'' +
                '}';
    }
}

public class Client {
    public static void main(String[] args) {
        //构建Phone对象
        Phone phone = new Phone("intel","三星屏幕","金士顿","华硕");
        System.out.println(phone);
    }
}
```

上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。

**重构后代码：**

```java
public class Phone {

    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    private Phone(Builder builder) {
        cpu = builder.cpu;
        screen = builder.screen;
        memory = builder.memory;
        mainboard = builder.mainboard;
    }

    public static final class Builder {
        private String cpu;
        private String screen;
        private String memory;
        private String mainboard;

        public Builder() {}

        public Builder cpu(String val) {
            cpu = val;
            return this;
        }
        public Builder screen(String val) {
            screen = val;
            return this;
        }
        public Builder memory(String val) {
            memory = val;
            return this;
        }
        public Builder mainboard(String val) {
            mainboard = val;
            return this;
        }
        public Phone build() {
            return new Phone(this);}
    }
    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", mainboard='" + mainboard + '\'' +
                '}';
    }
}

public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone.Builder()
                .cpu("intel")
                .mainboard("华硕")
                .memory("金士顿")
                .screen("三星")
                .build();
        System.out.println(phone);
    }
}
```

重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。

## 4.6 创建者模式对比

### 4.6.1 工厂方法模式VS建造者模式

工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。

我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。

### 4.6.2 抽象工厂模式VS建造者模式

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。

建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。

如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。

# 5，结构型模式

结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。

由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。

结构型模式分为以下 7 种：

* 代理模式
* 适配器模式
* 装饰者模式
* 桥接模式
* 外观模式
* 组合模式
* 享元模式



## 5.1 代理模式

### 5.1.1 概述

由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。

### 5.1.2 结构

代理（Proxy）模式分为三种角色：

* 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。
* 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
* 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

### 5.1.3 静态代理

我们通过案例来感受一下静态代理。

【例】火车站卖票

如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：

![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/静态代理.png)

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210909180042.png)

2. 卖火车票的接口

   ```java
   package static_proxy;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName SellTickets
    * @createTime 2021年09月09日 17:51:00
    * @Description 卖火车票的接口
    */
   public interface SellTickets {
   
       void sell();
   }
   ```

3. 火车站类

   ```java
   package static_proxy;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName TrainStation
    * @createTime 2021年09月09日 17:52:00
    * @Description 火车站类
    */
   public class TrainStation implements SellTickets{
       @Override
       public void sell() {
           System.out.println("火车站卖票");
       }
   }
   ```

4. 代售点类

   ```java
   package static_proxy;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName ProxyPoint
    * @createTime 2021年09月09日 17:53:00
    * @Description 代售点类
    */
   public class ProxyPoint implements SellTickets{
   
       //声明火车站类对象
       private TrainStation trainStation = new TrainStation();
   
       @Override
       public void sell() {
           System.out.println("代理点收取一些服务费用");
           trainStation.sell();
       }
   }
   ```

5. 测试类

   ```java
   package static_proxy;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月09日 17:54:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) {
           //创建代售点类对象
           ProxyPoint proxyPoint = new ProxyPoint();
           //调用方法进行买票
           proxyPoint.sell();
       }
   }
   ```

从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。

### 5.1.4 JDK动态代理

接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。

**案例演示**

1. 最终项目目录结构，如图所示：

   ![](https://gitee.com/jasonM4A1/pictureHost/raw/master/img/20210909182553.png)

2. 卖火车票的接口

   ```java
   package xyz.rtx3090.proxy.jdk_proxy;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName SellTickets
    * @createTime 2021年09月09日 17:51:00
    * @Description 卖火车票的接口
    */
   public interface SellTickets {
   
       void sell();
   }
   ```

3. 火车站类

   ```java
   package xyz.rtx3090.proxy.jdk_proxy;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName TrainStation
    * @createTime 2021年09月09日 17:52:00
    * @Description 火车站类
    */
   public class TrainStation implements SellTickets {
       @Override
       public void sell() {
           System.out.println("火车站卖票");
       }
   }
   ```

4. 代理对象的工厂类

   ```java
   package xyz.rtx3090.proxy.jdk_proxy;
   
   import java.lang.reflect.InvocationHandler;
   import java.lang.reflect.Method;
   import java.lang.reflect.Proxy;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName ProxyFactory
    * @createTime 2021年09月09日 18:04:00
    * @Description 代理对象的工厂类
    *              代理类也实现了对应的接口
    */
   public class ProxyFactory {
   
       //声明目标对象
       private TrainStation station = new TrainStation();
   
       public SellTickets getProxyObject() {
           //返回代理对象
           /*
           newProxyInstance()方法参数：
               ClassLoader loader: 类加载器，用于加载代理类，可以通过目标对象获取类加载器
               Class<?>[] interfaces: 代理类实现的接口的字节码对象
               InvocationHandler h: 代理对象的调用处理程序
            */
           SellTickets proxyObject = (SellTickets) Proxy.newProxyInstance(
                   station.getClass().getClassLoader(),
                   station.getClass().getInterfaces(),
                   new InvocationHandler() {
                       /*
                       invoke()方法参数：
                           Object proxy: 代理对象，和proxyObject对象是同一个对象，在invoke方法中基本不用
                           Method method: 对接口中的方法进行封装的method对象
                           Object args: 调用方法的参数列表
                       invoke()方法返回值：
                           代理方法的返回值
                        */
                       @Override
                       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                           //代理增强
                           System.out.println("代售点收取一定服务费用（jdk动态代理）");
                           //执行目标对象的方法
                           Object obj = method.invoke(station, args);
                           return obj;
                       }
                   }
           );
           return proxyObject;
       }
   }
   ```

5. 测试类

   ```java
   package xyz.rtx3090.proxy.jdk_proxy;
   
   /**
    * @author BernardoLi
    * @version 1.0.0
    * @ClassName Client
    * @createTime 2021年09月09日 18:09:00
    * @Description 测试类
    */
   public class Client {
       public static void main(String[] args) {
           //获取代理对象
           //1.创建代理工厂对象
           ProxyFactory proxyFactory = new ProxyFactory();
           //2.使用工厂对象的方法获取代理对象
           SellTickets proxyObject = proxyFactory.getProxyObject();
           //3.调用卖电脑的方法
           proxyObject.sell();
       }
   }
   ```

**使用了动态代理，我们思考下面问题：**

* ProxyFactory是代理类吗？

  ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：
  
  ```java
    package com.sun.proxy;
    
    import com.itheima.proxy.dynamic.jdk.SellTickets;
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.lang.reflect.UndeclaredThrowableException;
    
    public final class $Proxy0 extends Proxy implements SellTickets {
        private static Method m1;
        private static Method m2;
        private static Method m3;
        private static Method m0;
    
        public $Proxy0(InvocationHandler invocationHandler) {
            super(invocationHandler);
        }
    
        static {
            try {
                m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
                m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
                m3 = Class.forName("com.itheima.proxy.dynamic.jdk.SellTickets").getMethod("sell", new Class[0]);
                m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
                return;
            }
            catch (NoSuchMethodException noSuchMethodException) {
                throw new NoSuchMethodError(noSuchMethodException.getMessage());
            }
            catch (ClassNotFoundException classNotFoundException) {
                throw new NoClassDefFoundError(classNotFoundException.getMessage());
            }
        }
    
        public final boolean equals(Object object) {
            try {
                return (Boolean)this.h.invoke(this, m1, new Object[]{object});
            }
            catch (Error | RuntimeException throwable) {
                throw throwable;
            }
            catch (Throwable throwable) {
                throw new UndeclaredThrowableException(throwable);
            }
        }
    
        public final String toString() {
            try {
                return (String)this.h.invoke(this, m2, null);
            }
            catch (Error | RuntimeException throwable) {
                throw throwable;
            }
            catch (Throwable throwable) {
                throw new UndeclaredThrowableException(throwable);
            }
        }
    
        public final int hashCode() {
            try {
                return (Integer)this.h.invoke(this, m0, null);
            }
            catch (Error | RuntimeException throwable) {
                throw throwable;
            }
            catch (Throwable throwable) {
                throw new UndeclaredThrowableException(throwable);
            }
        }
    
        public final void sell() {
            try {
                this.h.invoke(this, m3, null);
                return;
            }
            catch (Error | RuntimeException throwable) {
                throw throwable;
            }
            catch (Throwable throwable) {
                throw new UndeclaredThrowableException(throwable);
            }
        }
    }
  ```

从上面的类中，我们可以看到以下几个信息：

  * 代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。
  * 代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。

* 动态代理的执行流程是什么样？

  下面是摘取的重点代码：

  ```java
  //程序运行过程中动态生成的代理类
  public final class $Proxy0 extends Proxy implements SellTickets {
      private static Method m3;
  
      public $Proxy0(InvocationHandler invocationHandler) {
          super(invocationHandler);
      }
  
      static {
          m3 = Class.forName("com.itheima.proxy.dynamic.jdk.SellTickets").getMethod("sell", new Class[0]);
      }
  
      public final void sell() {
          this.h.invoke(this, m3, null);
      }
  }
  
  //Java提供的动态代理相关类
  public class Proxy implements java.io.Serializable {
  	protected InvocationHandler h;
  	 
  	protected Proxy(InvocationHandler h) {
          this.h = h;
      }
  }
  
  //代理工厂类
  public class ProxyFactory {
  
      private TrainStation station = new TrainStation();
  
      public SellTickets getProxyObject() {
          SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                  station.getClass().getInterfaces(),
                  new InvocationHandler() {
                      
                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  
                          System.out.println("代理点收取一些服务费用(JDK动态代理方式)");
                          Object result = method.invoke(station, args);
                          return result;
                      }
                  });
          return sellTickets;
      }
  }
  
  
  //测试访问类
  public class Client {
      public static void main(String[] args) {
          //获取代理对象
          ProxyFactory factory = new ProxyFactory();
          SellTickets proxyObject = factory.getProxyObject();
          proxyObject.sell();
      }
  }
  ```


执行流程如下：

  1. 在测试类中通过代理对象调用sell()方法
  2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法
  3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法
  4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法

### 5.1.5 CGLIB动态代理